React Tutorial by Akshay Saini

Episode 1:
  - hello world in HTML -> JS -> React (via cdn)
  React createElement, ReactDOM createRoot -> returns react objects
  render() processes these objects & returns html understandable by browser

Episode 2: npm, React (npm), Parcel
  - tree shaking
  - local server
  - dev build
  - HMR (Hot Module Replacement)
  - File Watching Algorithm
  - Caching (faster builds)
  - Image optimization
  - Minification
  - Bundling
  - Compress
  - consistent hashing
  - code splitting
  - Differentiate building (Support for older browsers)
  - HTTPS server
  - etc etc

Episode 3:
  - part 1: scripts to start dev server, build prod
    npx parcel index.html = npm run start = npm start (start is reserved word)
    npx parcel build index.html == npm run build != npm build
  - part 2: render() function
  - part 3:
      - JSX (HTML like syntax, but not html in JS), different from React.
      - return from createElement same as JSX statement
      - Redo Episode 1 using JSX
      - babel converts(transpiles) JSX code to React's create component
  - part 4:
    - React Element vs component
    - React Components: ClassBased (old) & Functional Components (new)
    - Function Components: Returns JSX
    - Redo Episode 1 using React Component
    - Component Composition (component inside component)
  - part 5:
    - JS inside JSX (JS Expressions)
    - React Element inside React Element
    - React Element inside React Component
    - React Component inside React Component
    - React Component inside React Element
    - JSX handles XSS (Cross Site Scripting), by sanitizing the data passed to JSX, i.e. within {}
    - ALl below are similar Inside JSX
      const Title = () => (
        <h1 id="heading">Hello world</h1>
      )
      - {Title()}
      - <Title />
      - <Title></Title>

Episode 4: Food delivery app
  - part 1: Planning/Design wireframe, base implementation, All restaurants cards same
  - part 2: ConfigDrivenUI, different Swiggy UI for Bengaluru, Delhi, Hyderabad etc (use map, key)

Episode 5: Code restructuring
  - part 1: Directory structure. js & jsx extension same. default & named export/import.
  - part 2: Hooks
    - Purpose of most of the UI frameworks is to keep UI & Data layer in sync.
      i.e. update UI on data change.
    - DOM -> HTML structure. (ex: <div><img /></div>)
    - VirtualDom -> JS representation of actual DOM
    - React -> Efficiently re-renders the DOMs. Good & efficient at DOM manipulation.
    - Properties:
      - Reconciliation Alg (React Fiber): concepts -> virtual DOM, Diff Alg
    - useState(): returns an arr (2), set to trigger ReactFiber on change

Episode 6: UI interaction with other services (external world)
  - part 1: Monolith VS Micro
  - part 2: useEffect(), Use Swiggy API. render -> Load skeleton -> API call -> re-render
  - part 3: Shimmer UI (change Loading to Empty cards)
  - part 5: login <=> logout switching (useState)
  - part 6: Search box

Episode 7: Routing
  - part 1: useEffect dependency param is optional. If not provided, useEffect is called on every render.
            If empty array, called once, on first render
  - part 2: router config/setup
  - part 3: About & Contact route & Page. useRouteError hook
  - part 4: Children routes. outlet react component. link for anchor tag redirection without page refresh
            Hence single page. On re-routing the components are re-arraged. Or loads appropriate component
          - Routing types -> (server & client) routing
  - part 5: Dynamic routing (restaurant page with dishes)
  - part 6: Nested routing (restaurant page with dishes & reviews)
    - Link component for every restaurant

Episode 8: class based component (older way of creating components)
  - extends React.component. super(props)
  - props & state. use this.state
  - update state variables: componentDidMount, called post component is mounted (post child component)
  - function based components: Use return in useEffect to clear setTimeOut
  - class based components: use componentDidUnmount to clear setTimeOut
  - https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/
  - why super(props) in class based componenets
  - async useEffect
  - PENDING IMPLEMENTATION (base)

Episode 9: Optimizing App
  - part 1: custom hooks, refactoring
  - part 3: custom hooks (API fetch, online/offline internet)
  - part 5: app chunking/splitting/dynamic bundling/lazy loading/ -> lazy, Suspense
  - PENDING IMPLEMENTATION (base)

Episode 10: Tailwing integration
  - part 1: Different ways of styling app
    - direct css
    - styled components
    - sass & scss
    - frameworks (material UI, bootstrap, chakra ui, ant design etc)
    - tailwind
  - part 2: 

Episode 11: Higher Order Components
  - part 1: Accepts a component & returns a component (promoted restaurants)
    - HOC are pure functions, i.e. not modifying any behaviour of the receiving component
  - part 2: controlled & uncontrolled components. Lifting states up
    - Restaurent page same as swiggy's with all categories & it's items
    - on one expand collapse all others
    - ReactDevTool extension
    - controller & uncontrolled by parent component
    - PENDING: Collapse all accordions
  - part 3: context
    - Accessing context in Class based component -> UserContext.Consumer
    - Updating attribute value in context -> UserContext.Provider
    - Nested level UserContext.Provider. Appropriate updated value will be used

Episode 12: Redux
  - part 1: Redux setup (zustand alternate)
  - part 2: Redux Tool Kit (RTK), older version (Vanilla Redux)
    - Vanilla Redux: Was hard to configure & Big Learning Curve
    - RTK: Simpler & Just has BoilerPlate
    - RTK with ReactRedux
  - part 3:
    - Redux store is divided into slices (card, user, etc slices)
    - Each slice stores data related to it
    - Write: dispatch an action on action (ex: On click)
      - action calls reducer function & reducer function modifies the redux store (slice)
    - Read: Selector will provide the data. i.e. cart component Subscribes to selector
      - Hence when data changes in Slice, selector updates the data in it's subscribers
  - part 4: implementation
    - install redux
    - build store
    - connect store to app
    - create slice (cart slice)
    - dispatch action
    - selector (subscribe)
  - part 5: Always subscribe to right state (cart items in this case)
  - part 6: reducer in main Store, reducers for function definitions, reducer while exporting from slice
  - part 7:
    - Vanilla Redux -> Do not mutate states
      - Vanilla Redux: Instead create a new copy of state, update & return
      - return new state was mandatory
      - Used thungs & middleware to make API calls
    - RTK: Mutate the state (MUST)
      - RTK does the what develop used to do in vanilla redux
      - Immer does the above in RTK
      - return not mandatory
      - logging in RTK, use current func from redux
      - reducers must either mutate or return the new state
      - Uses RTK query (instead of thungs & middleware)
    - part 8: Redux dev tools (chrome extension)
      - explore RTK query

Episode 13: 